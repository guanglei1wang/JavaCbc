// Targeted by JavaCPP version 1.5.2-SNAPSHOT: DO NOT EDIT THIS FILE
package org.bytedeco.cbc.presets;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class Cbc extends CbcConfig {
    static {
        System.out.println("java.library.path: " + System.getProperty("java.library.path"));
        Loader.load();
    }

// Parsed from Cbc_C_Interface.h

/* $Id$ */
/*
  Copyright (C) 2004 International Business Machines Corporation and others.
  All Rights Reserved.

  This code is licensed under the terms of the Eclipse Public License (EPL).
*/
// #ifndef CbcModelC_H
// #define CbcModelC_H

/* include all defines and ugly stuff */
// #include "Coin_C_defines.h"
// #include <stddef.h>

/*
 * Original version contributed by Bob Entriken,
 * significantly updated by Miles Lubin.
 * 2018: several updates by Haroldo 
 */

// #ifdef __cplusplus
// #endif

/** Current version of Cbc */
public static native @Cast("const char*") BytePointer Cbc_getVersion();

/** \name Problem creation and modification routines */

/** \brief Creates an empty problem */
public static native Cbc_Model Cbc_newModel();

/** \brief Sets problem name.
     *
     * @param model problem object
     * @param array string with problem name
     **/
public static native int Cbc_setProblemName(Cbc_Model model, @Cast("const char*") BytePointer array);
public static native int Cbc_setProblemName(Cbc_Model model, String array);

/** \brief activates/deactivates name indexes
 *
 * @param model problem object
 * @param store: 1 maintain indexes of column and constraints names for searching indexes, 0 not
 **/
public static native void Cbc_storeNameIndexes(Cbc_Model model, @Cast("char") byte _store);

/** \brief searches columns by name and returns its index
 *
 * call Cbc_storeNameIndexes to enable search by name
 *
 * @param model problem object
 * @param name column (variable) name
 * @return column index or -1 if not found
 **/
public static native int Cbc_getColNameIndex(Cbc_Model model, @Cast("const char*") BytePointer name);
public static native int Cbc_getColNameIndex(Cbc_Model model, String name);

/** \brief searches rows by name and returns its index
 *
 * call Cbc_storeNameIndexes to enable search by name
 *
 * @param model problem object
 * @param name row (constraint) name
 * @return row index or -1 if not found
 **/
public static native int Cbc_getRowNameIndex(Cbc_Model model, @Cast("const char*") BytePointer name);
public static native int Cbc_getRowNameIndex(Cbc_Model model, String name);

/** \brief Creates a new column
     *
     * Creates a new column (variable)
     *
     * @param model problem object
     * @param name variable name
     * @param lb column lower bound
     * @param ub column upper bound
     * @param obj objective function coefficient
     * @param isInteger 1 if variable is integral, 0 otherwise
     * @param nz number of rows (constraints) where this column appears, can be 0 if constraints will be added later
     * @param rows index of rows where this column appears, NULL if rows will be added later
     * @param coefs coefficients that this column appears in its rows, NULL if rows will be added later
     ***/
public static native void Cbc_addCol(Cbc_Model model, @Cast("const char*") BytePointer name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntPointer rows, DoublePointer coefs);
public static native void Cbc_addCol(Cbc_Model model, String name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntBuffer rows, DoubleBuffer coefs);
public static native void Cbc_addCol(Cbc_Model model, @Cast("const char*") BytePointer name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, int[] rows, double[] coefs);
public static native void Cbc_addCol(Cbc_Model model, String name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntPointer rows, DoublePointer coefs);
public static native void Cbc_addCol(Cbc_Model model, @Cast("const char*") BytePointer name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntBuffer rows, DoubleBuffer coefs);
public static native void Cbc_addCol(Cbc_Model model, String name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, int[] rows, double[] coefs);


/** \brief Deletes some columns
     *
     *  Deletes some columns (variables)
     *
     *  @param model problem object
     *  @param numCols 
     *  @param cols columns that will be deleted
     * */
public static native void Cbc_deleteCols(Cbc_Model model, int numCols, @Const IntPointer cols);
public static native void Cbc_deleteCols(Cbc_Model model, int numCols, @Const IntBuffer cols);
public static native void Cbc_deleteCols(Cbc_Model model, int numCols, @Const int[] cols);

/** \brief Adds a new row 
     *
     *  Adds a new row (linear constraint) to the problem
     *
     *  @param model problem object
     *  @param name constraint name
     *  @param nz number of variables with non-zero coefficients in this row
     *  @param cols index of variables that appear in this row
     *  @param coefs cofficients that that variables appear
     *  @param sense constraint sense: L if <=, G if >=, E if =, R if ranged and N if free
     *  @param rhs right hand size
     * */
public static native void Cbc_addRow(Cbc_Model model, @Cast("const char*") BytePointer name, int nz,
  @Const IntPointer cols, @Const DoublePointer coefs, @Cast("char") byte sense, double rhs);
public static native void Cbc_addRow(Cbc_Model model, String name, int nz,
  @Const IntBuffer cols, @Const DoubleBuffer coefs, @Cast("char") byte sense, double rhs);
public static native void Cbc_addRow(Cbc_Model model, @Cast("const char*") BytePointer name, int nz,
  @Const int[] cols, @Const double[] coefs, @Cast("char") byte sense, double rhs);
public static native void Cbc_addRow(Cbc_Model model, String name, int nz,
  @Const IntPointer cols, @Const DoublePointer coefs, @Cast("char") byte sense, double rhs);
public static native void Cbc_addRow(Cbc_Model model, @Cast("const char*") BytePointer name, int nz,
  @Const IntBuffer cols, @Const DoubleBuffer coefs, @Cast("char") byte sense, double rhs);
public static native void Cbc_addRow(Cbc_Model model, String name, int nz,
  @Const int[] cols, @Const double[] coefs, @Cast("char") byte sense, double rhs);

/** \brief Deletes some rows
     *
     *  Deletes some rows from the model
     *
     *  @param model problem object
     *  @param numRows number of rows
     *  @param rows rows to be deleted
     * */
public static native void Cbc_deleteRows(Cbc_Model model, int numRows, @Const IntPointer rows);
public static native void Cbc_deleteRows(Cbc_Model model, int numRows, @Const IntBuffer rows);
public static native void Cbc_deleteRows(Cbc_Model model, int numRows, @Const int[] rows);

/** \brief Add SOS constraints to the model using row-order matrix */
public static native void Cbc_addSOS(Cbc_Model model, int numRows, @Const IntPointer rowStarts,
  @Const IntPointer colIndices, @Const DoublePointer weights, int type);
public static native void Cbc_addSOS(Cbc_Model model, int numRows, @Const IntBuffer rowStarts,
  @Const IntBuffer colIndices, @Const DoubleBuffer weights, int type);
public static native void Cbc_addSOS(Cbc_Model model, int numRows, @Const int[] rowStarts,
  @Const int[] colIndices, @Const double[] weights, int type);

/** Loads a problem (the constraints on the
        rows are given by lower and upper bounds). If a pointer is NULL then the
        following values are the default:
        <ul>
        <li> <code>colub</code>: all columns have upper bound infinity
        <li> <code>collb</code>: all columns have lower bound 0
        <li> <code>rowub</code>: all rows have upper bound infinity
        <li> <code>rowlb</code>: all rows have lower bound -infinity
        <li> <code>obj</code>: all variables have 0 objective coefficient
        </ul>
     <p>
     The constraint matrix is
     given in standard compressed sparse column (without gaps).
     <ul>
     <li> <code>start[i]</code> stores the starting index of the ith column
     <li> <code>index[k]</code> stores the row index of the kth nonzero element
     <li> <code>value[k]</code> stores the coefficient of the kth nonzero element
     </ul>
    */
public static native void Cbc_loadProblem(Cbc_Model model, int numcols, int numrows,
  @Cast("const CoinBigIndex*") IntPointer start, @Const IntPointer index,
  @Const DoublePointer value,
  @Const DoublePointer collb, @Const DoublePointer colub,
  @Const DoublePointer obj,
  @Const DoublePointer rowlb, @Const DoublePointer rowub);
public static native void Cbc_loadProblem(Cbc_Model model, int numcols, int numrows,
  @Cast("const CoinBigIndex*") IntPointer start, @Const IntBuffer index,
  @Const DoubleBuffer value,
  @Const DoubleBuffer collb, @Const DoubleBuffer colub,
  @Const DoubleBuffer obj,
  @Const DoubleBuffer rowlb, @Const DoubleBuffer rowub);
public static native void Cbc_loadProblem(Cbc_Model model, int numcols, int numrows,
  @Cast("const CoinBigIndex*") IntPointer start, @Const int[] index,
  @Const double[] value,
  @Const double[] collb, @Const double[] colub,
  @Const double[] obj,
  @Const double[] rowlb, @Const double[] rowub);

/** \brief Set the name of a column 
     *
     * @param model problem object 
     * @param iColumn column index
     * @param column name
     **/
public static native void Cbc_setColName(Cbc_Model model, int iColumn, @Cast("const char*") BytePointer name);
public static native void Cbc_setColName(Cbc_Model model, int iColumn, String name);

/** \brief Set the name of a row 
     *
     * @param model problem object 
     * @param iRow row index
     * @param name row name
     **/
public static native void Cbc_setRowName(Cbc_Model model, int iRow, @Cast("const char*") BytePointer name);
public static native void Cbc_setRowName(Cbc_Model model, int iRow, String name);

/** \brief Sets optimization direction
    *
    * @param model problem object 
    * @param sense: direction of optimization (1 - minimize, -1 - maximize, 0 - ignore)
    **/
public static native void Cbc_setObjSense(Cbc_Model model, double sense);

/** \brief Set the lower bound of a single constraint 
     *
     * @param model problem object 
     * @param index row index
     * @param value new row lower bound
     **/
public static native void Cbc_setRowLower(Cbc_Model model, int index, double value);

/** \brief  Set the upper bound of a single constraint 
     *
     * @param model problem object 
     * @param index row index
     * @param value new row upper bound
     **/
public static native void Cbc_setRowUpper(Cbc_Model model, int index, double value);

/** \brief Set the objective coefficient of a single variable 
     *
     * @param model problem object 
     * @param index variable index
     * @param value new objective function coefficient for this variable
     **/
public static native void Cbc_setObjCoeff(Cbc_Model model, int index, double value);

/** \brief Set the lower bound of a single variable 
     *
     * @param model problem object 
     * @param index variable index
     * @param value variable lower bound
     **/
public static native void Cbc_setColLower(Cbc_Model model, int index, double value);

/** \brief Set the upper bound of a single variable 
     *
     * @param model problem object 
     * @param index variable index
     * @param value new variable upper bound
     **/
public static native void Cbc_setColUpper(Cbc_Model model, int index, double value);

/** \brief Set this variable to be continuous 
     *
     * @param model problem object 
     * @param iColumn column index
     **/
public static native void Cbc_setContinuous(Cbc_Model model, int iColumn);

/** \brief Set this variable to be integer 
     *
     * @param model problem object 
     * @param iColumn column index
     **/
public static native void Cbc_setInteger(Cbc_Model model, int iColumn);

/** \brief Cbc_Model destructor */
public static native void Cbc_deleteModel(Cbc_Model model);

/** \brief Enter initial feasible solution 
     *
     * Enter an initial feasible solution. Only the non-zero main 
     * binary/integer decision variables need to be informed. 
     * Auxiliary and/or continuous variables are computed 
     * automatically.
     * 
     * @param model problem object 
     * @param count number of variables
     * @param colNames names of variables
     * @param colValues variable values
     *
     **/
public static native void Cbc_setMIPStart(Cbc_Model model, int count, @Cast("const char**") PointerPointer colNames, @Const DoublePointer colValues);
public static native void Cbc_setMIPStart(Cbc_Model model, int count, @Cast("const char**") @ByPtrPtr BytePointer colNames, @Const DoublePointer colValues);
public static native void Cbc_setMIPStart(Cbc_Model model, int count, @Cast("const char**") @ByPtrPtr ByteBuffer colNames, @Const DoubleBuffer colValues);
public static native void Cbc_setMIPStart(Cbc_Model model, int count, @Cast("const char**") @ByPtrPtr byte[] colNames, @Const double[] colValues);

/** \brief Enter initial feasible solution 
     *
     * Enter an initial feasible solution. Only the non-zero main 
     * binary/integer decision variables need to be informed. 
     * Auxiliary and/or continuous variables are computed 
     * automatically. Same as setMIPStart but using variable indexes.
     * 
     * @param model problem object 
     * @param count number of variables
     * @param colIdxs indexes of variables
     * @param colValues variable values
     *
     **/
public static native void Cbc_setMIPStartI(Cbc_Model model, int count, @Const IntPointer colIdxs, @Const DoublePointer colValues);
public static native void Cbc_setMIPStartI(Cbc_Model model, int count, @Const IntBuffer colIdxs, @Const DoubleBuffer colValues);
public static native void Cbc_setMIPStartI(Cbc_Model model, int count, @Const int[] colIdxs, @Const double[] colValues);

/** \brief Creates a copy of the current model 
     *
     * @param model problem object 
     * @return model copy
     **/
public static native Cbc_Model Cbc_clone(Cbc_Model model);

/** \name Routines to query problem contents
*/

/** \brief Queries problem name 
     *
     * @param model problem object
     * @param maxNumberCharacters space in string array
     * @param array string where problem name will be saved
     **/
public static native void Cbc_problemName(Cbc_Model model, int maxNumberCharacters, @Cast("char*") BytePointer array);
public static native void Cbc_problemName(Cbc_Model model, int maxNumberCharacters, @Cast("char*") ByteBuffer array);
public static native void Cbc_problemName(Cbc_Model model, int maxNumberCharacters, @Cast("char*") byte[] array);

/** \brief Number of nonzero elements in constraint matrix 
     *
     * @param model problem object
     * @return number of non-zero entries in constraint matrix
     **/
public static native int Cbc_getNumElements(Cbc_Model model);

/** \brief Number of variables in the model 
     * @param model problem object
     * @return number of columns (variables)
     **/
public static native int Cbc_getNumCols(Cbc_Model model);

/** \brief Number of integer variables in the model 
     *
     * @param model problem object
     * @return number of integer variables in this model
     **/
public static native int Cbc_getNumIntegers(Cbc_Model model);

/** Number of constraints in the model 
     * @param model problem object
     * @return number of rows (constraints) in the model
     **/
public static native int Cbc_getNumRows(Cbc_Model model);

/** \brief Queries row name 
     *
     * @param model problem object 
     * @param row index
     * @param name string where row name will be stored
     * @param string where row name will be stored
     **/
public static native void Cbc_getRowName(Cbc_Model model, int iRow, @Cast("char*") BytePointer name, @Cast("size_t") long maxLength);
public static native void Cbc_getRowName(Cbc_Model model, int iRow, @Cast("char*") ByteBuffer name, @Cast("size_t") long maxLength);
public static native void Cbc_getRowName(Cbc_Model model, int iRow, @Cast("char*") byte[] name, @Cast("size_t") long maxLength);

/** Queries column name
     *
     * @param model problem object 
     * @param iColumn column index
     * @param name where name will be stored
     * @param maxLength maximum length of name string
     **/
public static native void Cbc_getColName(Cbc_Model model, int iColumn, @Cast("char*") BytePointer name, @Cast("size_t") long maxLength);
public static native void Cbc_getColName(Cbc_Model model, int iColumn, @Cast("char*") ByteBuffer name, @Cast("size_t") long maxLength);
public static native void Cbc_getColName(Cbc_Model model, int iColumn, @Cast("char*") byte[] name, @Cast("size_t") long maxLength);

/** \brief Number of non-zero entries in a row 
     *
     * @param model problem object 
     * @param row row index
     * @return number of non-zero entries in row
     **/
public static native int Cbc_getRowNz(Cbc_Model model, int row);

/** \brief Indices of variables that appear on a row 
     *
     * @param model problem object 
     * @param row row index
     * @return vector with indexes of columns that appear on this row
     **/
public static native @Const IntPointer Cbc_getRowIndices(Cbc_Model model, int row);

/** \brief Coefficients of variables that appear on this row 
     *
     * @param model problem object 
     * @param row row index
     * @return coefficients of variables that appear on this row
     **/
public static native @Const DoublePointer Cbc_getRowCoeffs(Cbc_Model model, int row);

/** \brief Number of non-zero entries in a column 
     *
     * @param model problem object 
     * @param col column index
     * @return numbef of rows that this column appears
     **/
public static native int Cbc_getColNz(Cbc_Model model, int col);

/** \brief Indices of rows that a column appears 
     *
     * @param model problem object 
     * @param col column index
     * @return indices of rows that this column appears
     **/
public static native @Const IntPointer Cbc_getColIndices(Cbc_Model model, int col);

/** \brief Coefficients that a column appear in rows 
     *
     * @param model problem object 
     * @param col column index
     * @return coefficients of this column in rows
     **/
public static native @Const DoublePointer Cbc_getColCoeffs(Cbc_Model model, int col);

/** \brief Right hand side of a row 
     *
     * @param model problem object 
     * @param row row index
     * @return row right hand side
     **/
public static native double Cbc_getRowRHS(Cbc_Model model, int row);

/** \brief Sense a row 
     * @param model problem object 
     * @param row row index
     * @return row sense: E for =, L for <=, G for >= and R for ranged row
     **/
public static native @Cast("char") byte Cbc_getRowSense(Cbc_Model model, int row);

/** \brief Direction of optimization 
     *
     * @param model problem object 
     * @return Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore) 
     **/
public static native double Cbc_getObjSense(Cbc_Model model);

/** \brief Constraint lower bounds 
     *
     * @param model problem object 
     * @return vector with lower bounds of constraints
     **/
public static native @Const DoublePointer Cbc_getRowLower(Cbc_Model model);

/** \brief Constraint upper bounds 
     *
     * @param model problem object 
     * @return constraint upper bounds
     **/
public static native @Const DoublePointer Cbc_getRowUpper(Cbc_Model model);

/** \brief Objective vector 
     *
     * @param model problem object 
     * @return vector with coefficients of variables in the objective function
     **/
public static native @Const DoublePointer Cbc_getObjCoefficients(Cbc_Model model);

/** \brief Variable lower bounds 
     *
     * @param model problem object 
     * @return vector with lower bounds of variables
     **/
public static native @Const DoublePointer Cbc_getColLower(Cbc_Model model);

/** \brief Variable upper bounds 
     *
     * @param model problem object 
     * @return vector with column upper bounds
     **/
public static native @Const DoublePointer Cbc_getColUpper(Cbc_Model model);

/** \brief Determine whether the ith variable is integer restricted 
     * 
     * @param model problem object 
     * @param i variable index
     * @return 1 if variable is integer, 0 otherwise
     **/
public static native int Cbc_isInteger(Cbc_Model model, int i);


/** \name Routines to load and save problems from disk
*/

/** \brief Read an mps file from the given filename 
    * 
    * @param model problem object
    * @param fileName file name 
    **/
public static native int Cbc_readMps(Cbc_Model model, @Cast("const char*") BytePointer filename);
public static native int Cbc_readMps(Cbc_Model model, String filename);

/** \brief Read an lp file from the given filename 
     *
     * @param model problem object
     * @param fileName file name 
     **/
public static native int Cbc_readLp(Cbc_Model model, @Cast("const char*") BytePointer filename);
public static native int Cbc_readLp(Cbc_Model model, String filename);

/** \brief Write an mps file from the given filename 
     *
     * @param model problem object
     * @param fileName file name 
     **/
public static native void Cbc_writeMps(Cbc_Model model, @Cast("const char*") BytePointer filename);
public static native void Cbc_writeMps(Cbc_Model model, String filename);

/** \brief Write an lp file from the given filename 
     *
     * @param model problem object
     * @param fileName file name 
     **/
public static native void Cbc_writeLp(Cbc_Model model, @Cast("const char*") BytePointer filename);
public static native void Cbc_writeLp(Cbc_Model model, String filename);


/**\name Getting and setting model data
     Note that problem access and modification methods,
       such as getColLower and setColLower,
       are *not valid* after calling Cbc_solve().
       Therefore it is not recommended to reuse a Cbc_Model
       object for multiple solves. A workaround is to call Cbc_clone()
       before solving.
     * */
/*@{*/

/** Provide an initial feasible solution to accelerate branch-and-bound 
     Note that feasibility of the solution is *not* verified.
    */
public static native void Cbc_setInitialSolution(Cbc_Model model, @Const DoublePointer sol);
public static native void Cbc_setInitialSolution(Cbc_Model model, @Const DoubleBuffer sol);
public static native void Cbc_setInitialSolution(Cbc_Model model, @Const double[] sol);
/** "Column start" vector of constraint matrix. Same format as Cbc_loadProblem() */
public static native @Cast("const CoinBigIndex*") IntPointer Cbc_getVectorStarts(Cbc_Model model);
/** "Row index" vector of constraint matrix */
public static native @Const IntPointer Cbc_getIndices(Cbc_Model model);
/** Coefficient vector of constraint matrix */
public static native @Const DoublePointer Cbc_getElements(Cbc_Model model);

/** Maximum lenght of a row or column name */
public static native @Cast("size_t") long Cbc_maxNameLength(Cbc_Model model);
/** Print the model */
public static native void Cbc_printModel(Cbc_Model model, @Cast("const char*") BytePointer argPrefix);
public static native void Cbc_printModel(Cbc_Model model, String argPrefix);
/*@}*/

/**\name Solver parameters */
/*@{*/
/** Set parameter "name" to value "value". Note that this
     * translates directly to using "-name value" as a 
     * command-line argument to Cbc.*/
public static native void Cbc_setParameter(Cbc_Model model, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer value);
public static native void Cbc_setParameter(Cbc_Model model, String name, String value);


/** returns the allowable gap
 */
public static native double Cbc_getAllowableGap(Cbc_Model model);

/** sets the allowable gap
 */
public static native void Cbc_setAllowableGap(Cbc_Model model, double allowedGap);

/** returns the allowable fraction gap
 */
public static native double Cbc_getAllowableFractionGap(Cbc_Model model);

/** sets the allowable fraction gap
 */
public static native void Cbc_setAllowableFractionGap(Cbc_Model model, double allowedFracionGap);

/** returns the allowable percentage gap
 */
public static native double Cbc_getAllowablePercentageGap(Cbc_Model model);

/** sets the allowable percentage gap
 */
public static native void Cbc_setAllowablePercentageGap(Cbc_Model model, double allowedPercentageGap);

/** returns the time limit for the search process
 */
public static native double Cbc_getMaximumSeconds(Cbc_Model model);

/** sets the time limit for the search process
 */
public static native void Cbc_setMaximumSeconds(Cbc_Model model, double maxSeconds);


/** returns the maximum number of nodes that can be explored in the search tree
 */
public static native int Cbc_getMaximumNodes(Cbc_Model model);

/** sets the maximum number of nodes that can be explored in the search tree
 */
public static native void Cbc_setMaximumNodes(Cbc_Model model, int maxNodes);

/** returns solution limit for the search process
 */
public static native int Cbc_getMaximumSolutions(Cbc_Model model);

/** sets a solution limit as a stopping criterion 
 */
public static native void Cbc_setMaximumSolutions(Cbc_Model model, int maxSolutions);

/** returns the current log leven
 */
public static native int Cbc_getLogLevel(Cbc_Model model);

/** sets the log level
 */
public static native void Cbc_setLogLevel(Cbc_Model model, int logLevel);


/** returns the cutoff
 */
public static native double Cbc_getCutoff(Cbc_Model model);

/** sets the cutoff
 */
public static native void Cbc_setCutoff(Cbc_Model model, double cutoff);



/*@}*/
/**\name Message handling.  */
/*@{*/
/** Pass in Callback function.
     Message numbers up to 1000000 are Clp, Coin ones have 1000000 added */
public static native void Cbc_registerCallBack(Cbc_Model model,
  @ByVal cbc_callback userCallBack);

/** Unset Callback function */
public static native void Cbc_clearCallBack(Cbc_Model model);

/** calback to generate cutting planes **/
public static native void Cbc_addCutCallback( 
    Cbc_Model model, @ByVal cbc_cut_callback cutcb, 
    @Cast("const char*") BytePointer name, Pointer appData );
public static native void Cbc_addCutCallback( 
    Cbc_Model model, @ByVal cbc_cut_callback cutcb, 
    String name, Pointer appData );


/*@}*/

/**\name Solving the model */
/*@{*/
/* Solve the model with Cbc (using CbcMain1).
    */
public static native int Cbc_solve(Cbc_Model model);
/*@}*/

/**\name Accessing the solution and optimization status */
/*@{*/

/** \brief Best feasible solution vector 
     *
     * @param model problem object
     * @return vector with best solution found
     **/
public static native @Const DoublePointer Cbc_getColSolution(Cbc_Model model);


/** \brief Best known bound on the optimal objective value 
     *
     * @param model problem object
     * @return best possible cost (lower bound)
     **/
public static native double Cbc_getBestPossibleObjValue(Cbc_Model model);

/** \brief Best integer feasible solution 
     *
     * Best integer feasible solution or NULL if no integer feas sol found 
     *
     * @param model problem object
     * @return vector with the best solution found or NULL if no feasible solution was found
     **/
public static native DoublePointer Cbc_bestSolution(Cbc_Model model);

/** \brief number of integer feasible solution saved
     *
     * @param model problem object 
     * @return number of saved solutions
     **/
public static native int Cbc_numberSavedSolutions(Cbc_Model model);

/** \brief Vector with the i-th saved solution
     * 
     * @param model problem object 
     * @param whichSol index of the solution to be retrieved
     * @return vector with integer feasible solution
     **/
public static native @Const DoublePointer Cbc_savedSolution(Cbc_Model model, int whichSol);

/** \brief Cost of the whichSol solution
     *
     * @param model problem object 
     * @param whichSol solution index
     * @return solution cost
     **/
public static native double Cbc_savedSolutionObj(Cbc_Model model, int whichSol);

/** \brief Queries vector of reduced costs
     *
     * @param model problem object
     * @return reduced cost vector
     **/
public static native @Const DoublePointer Cbc_getReducedCost(Cbc_Model model);

/** \brief Queries vector of row prices (values for dual variables)
     *
     * @param model problem object
     * @return reduced cost vector
     **/
public static native @Const DoublePointer Cbc_getRowPrice(Cbc_Model model);

/** If optimization was abandoned due to numerical difficulties
     *
     * @param model problem object 
     * @return 1 if numerical difficulties interrupted the optimization, 0 otherwise
     * */
public static native int Cbc_isAbandoned(Cbc_Model model);

/** \brief If the optimal solution was found 
     *
     * @param model problem object 
     * @return 1 if optimal solution was found, 0 otherwise
     **/
public static native int Cbc_isProvenOptimal(Cbc_Model model);

/** \brief If infeasibility was proven
     *
     * If model is infeasible, please note that infeasibility can also be declared 
     * if cutoff is informed and no solution better than the cutoff exists.
     *
     * @param model problem object 
     * @return 1 if model is infeasible, 0 otherwise
     **/
public static native int Cbc_isProvenInfeasible(Cbc_Model model);

/** \brief Is continuous model unbounded ?
    *
    * @param model problem object 
    * @return 1 if model is unbounded, 0 otherwise
    * */
public static native int Cbc_isContinuousUnbounded(Cbc_Model model);

/** Objective value of best feasible solution 
     *
     * @param model problem object
     * @return cost of the best solution found
     * */
public static native double Cbc_getObjValue(Cbc_Model model);

/** \brief Final optimization status
     *
     * Returns the optimization status. For more info check function
     * isProvenOptimal, isProvenInfeasible, etc. Check also secondary status.
     * Possible status are:
     *
     * -1 before branchAndBound
     * 0 finished - check isProvenOptimal or isProvenInfeasible to see if solution found (or check value of best solution)
     * 1 stopped - on maxnodes, maxsols, maxtime
     * 2 execution abandoned due to numerical dificulties
     * 5 user programmed interruption
     *
     * @param model problem object 
     * @return problem status
    */
public static native int Cbc_status(Cbc_Model model);

/** \brief Secondary status of problem
     *
     * Returns additional information regarding the optimization status
     *
     * -1 unset (status_ will also be -1)
     *  0 search completed with solution
     *  1 linear relaxation not feasible (or worse than cutoff)
     *  2 stopped on gap
     *  3 stopped on nodes
     *  4 stopped on time
     *  5 stopped on user event
     *  6 stopped on solutions
     *  7 linear relaxation unbounded
     *  8 stopped on iteration limit
     *
     *  \model problem object 
     *  @return optimization status
    */
public static native int Cbc_secondaryStatus(Cbc_Model model);

/** Sum of primal infeasibilities */
public static native double Cbc_sumPrimalInfeasibilities(Cbc_Model model);

/** Number of primal infeasibilities */
public static native int Cbc_numberPrimalInfeasibilities(Cbc_Model model);

/** Just check solution (for external use) - sets sum of
        infeasibilities etc */
public static native void Cbc_checkSolution(Cbc_Model model);

/** Number of iterations */
public static native int Cbc_getIterationCount(Cbc_Model model);

/** Node limit reached? */
public static native int Cbc_isNodeLimitReached(Cbc_Model model);
/** Time limit reached? */
public static native int Cbc_isSecondsLimitReached(Cbc_Model model);
/** Solution limit reached? */
public static native int Cbc_isSolutionLimitReached(Cbc_Model model);
/** Are there numerical difficulties (for initialSolve) ? */
public static native int Cbc_isInitialSolveAbandoned(Cbc_Model model);
/** Is optimality proven (for initialSolve) ? */
public static native int Cbc_isInitialSolveProvenOptimal(Cbc_Model model);
/** Is primal infeasiblity proven (for initialSolve) ? */
public static native int Cbc_isInitialSolveProvenPrimalInfeasible(Cbc_Model model);
/** "row" solution
     *  This is the vector A*x, where A is the constraint matrix
     *  and x is the current solution. */
public static native @Const DoublePointer Cbc_getRowActivity(Cbc_Model model);
/** Number of nodes explored in B&B tree */
public static native int Cbc_getNodeCount(Cbc_Model model);
/** Print the solution */
public static native void Cbc_printSolution(Cbc_Model model);

/*@}*/

/** \name OsiSolverInterface related routines (used in callbacks) */

/** \brief Creates a new OsiClpSolverInterface and returns a pointer to an OsiSolverInterface object */
public static native Pointer Osi_newSolver();

/** \brief Solves initial LP relaxation */
public static native void Osi_initialSolve(Pointer osi);

/** \brief Reoptimizes linear program  */
public static native void Osi_resolve(Pointer osi);

/** \brief Performs branch and bound */
public static native void Osi_branchAndBound(Pointer osi);


/** \brief Checks if optimization was abandoned */
public static native @Cast("char") byte Osi_isAbandoned(Pointer osi);

/** \brief Checks if optimal solution was found */
public static native @Cast("char") byte Osi_isProvenOptimal(Pointer osi);

/** \brief Checks if problem is primal infeasible */
public static native @Cast("char") byte Osi_isProvenPrimalInfeasible(Pointer osi);

/** \brief Checks if problem is dual infeasible */
public static native @Cast("char") byte Osi_isProvenDualInfeasible(Pointer osi);

/** \brief Checks if primal objective limit was reached */
public static native @Cast("char") byte Osi_isPrimalObjectiveLimitReached(Pointer osi);

/** \brief Checks if dual objective limit was reached */
public static native @Cast("char") byte Osi_isDualObjectiveLimitReached(Pointer osi);

/** \brief Checks if iteration limit was reached */
public static native @Cast("char") byte Osi_isIterationLimitReached(Pointer osi);

/** \brief Returns number of cols in OsiSolverInterface object */
public static native int Osi_getNumCols( Pointer osi );

/** \brief Returns column name in OsiSolverInterface object */
public static native void Osi_getColName( Pointer osi, int i, @Cast("char*") BytePointer name, int maxLen );
public static native void Osi_getColName( Pointer osi, int i, @Cast("char*") ByteBuffer name, int maxLen );
public static native void Osi_getColName( Pointer osi, int i, @Cast("char*") byte[] name, int maxLen );

/** \brief Returns column lower bounds in OsiSolverInterface object */
public static native @Const DoublePointer Osi_getColLower( Pointer osi );

/** \brief Returns column upper bounds in OsiSolverInterface object */
public static native @Const DoublePointer Osi_getColUpper( Pointer osi );

/** \brief Returns integrality information for columns in OsiSolverInterface object */
public static native int Osi_isInteger( Pointer osi, int col );

/** \brief Returns number of rows in OsiSolverInterface object */
public static native int Osi_getNumRows( Pointer osi );

/** \brief Returns number non-zeros in the constraint matrix */
public static native int Osi_getNumNz( Pointer osi );

/** \brief Returns number integer/binary variables */
public static native int Osi_getNumIntegers( Pointer osi );

public static native int Osi_getRowNz(Pointer osi, int row);

/** \brief Indices of variables that appear on a row */
public static native @Const IntPointer Osi_getRowIndices(Pointer osi, int row);

/** \brief Coefficients of variables that appear on this row 
     *
     * @param model problem object 
     * @param row row index
     * @return coefficients of variables that appear on this row
     **/
public static native @Const DoublePointer Osi_getRowCoeffs(Pointer osi, int row);

/** \brief Right hand side of a row 
     *
     * @param model problem object 
     * @param row row index
     * @return row right hand side
     **/
public static native double Osi_getRowRHS(Pointer osi, int row);

/** \brief Sense a row 
     * @param model problem object 
     * @param row row index
     * @return row sense: E for =, L for <=, G for >= and R for ranged row
     **/
public static native @Cast("char") byte Osi_getRowSense(Pointer osi, int row);

/** \brief Returns vector with objective function coefficients */
public static native @Const DoublePointer Osi_getObjCoefficients();

/** \brief Returns the objective sense: 1 for MIN and -1 for MAX */
public static native double Osi_getObjSense();

/** \brief Returns solution vector in OsiSolverInterface object */
public static native @Const DoublePointer Osi_getColSolution( Pointer osi );

/** \brief Returns vector of reduced costs */
public static native @Const DoublePointer Osi_getReducedCost( Pointer osi );

/** \brief Returns of dual variables */
public static native @Const DoublePointer Osi_getRowPrice( Pointer osi );

/** \brief Returns the objective function value */
public static native double Osi_getObjValue( Pointer osi );

/** \brief Sets column upper bound */
public static native void Osi_setColUpper(Pointer osi, int elementIndex, double ub);

/** \brief Sets column upper bound */
public static native void Osi_setColLower(Pointer osi, int elementIndex, double lb);

/** \brief Sets one objective function coefficient */
public static native void Osi_setObjCoef(Pointer osi, int elementIndex, double obj);

/** \brief Sets optimization direction
    *
    * @param osi OsiSolverInterface object
    * @param sense: direction of optimization (1 - minimize, -1 - maximize, 0 - ignore)
    **/
public static native void Osi_setObjSense(Pointer osi, double sense);

/** \brief Sets a variable to integer */
public static native void Osi_setInteger(Pointer osi, int index);

/** \brief Sets a variable to continuous */
public static native void Osi_setContinuous(Pointer osi, int index);

/** \brief Number of non-zero entries in a column 
     *
     * @param model problem object 
     * @param col column index
     * @return numbef of rows that this column appears
     **/
public static native int Osi_getColNz(Pointer model, int col);

/** \brief Indices of rows that a column appears 
     *
     * @param model problem object 
     * @param col column index
     * @return indices of rows that this column appears
     **/
public static native @Const IntPointer Osi_getColIndices(Pointer model, int col);

/** \brief Coefficients that a column appear in rows 
     *
     * @param model problem object 
     * @param col column index
     * @return coefficients of this column in rows
     **/
public static native @Const DoublePointer Osi_getColCoeffs(Pointer model, int col);

/** \brief Creates a new column
     *
     * Creates a new column (variable)
     *
     * @param osi OsiSolverInterface object
     * @param name variable name
     * @param lb column lower bound
     * @param ub column upper bound
     * @param obj objective function coefficient
     * @param isInteger 1 if variable is integral, 0 otherwise
     * @param nz number of rows (constraints) where this column appears, can be 0 if constraints will be added later
     * @param rows index of rows where this column appears, NULL if rows will be added later
     * @param coefs coefficients that this column appears in its rows, NULL if rows will be added later
     ***/
public static native void Osi_addCol(Pointer osi, @Cast("const char*") BytePointer name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntPointer rows, DoublePointer coefs);
public static native void Osi_addCol(Pointer osi, String name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntBuffer rows, DoubleBuffer coefs);
public static native void Osi_addCol(Pointer osi, @Cast("const char*") BytePointer name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, int[] rows, double[] coefs);
public static native void Osi_addCol(Pointer osi, String name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntPointer rows, DoublePointer coefs);
public static native void Osi_addCol(Pointer osi, @Cast("const char*") BytePointer name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, IntBuffer rows, DoubleBuffer coefs);
public static native void Osi_addCol(Pointer osi, String name, double lb,
  double ub, double obj, @Cast("char") byte isInteger,
  int nz, int[] rows, double[] coefs);

/** \brief Adds a new row 
     *
     *  Adds a new row (linear constraint) to the problem
     *
     *  @param osi OsiSolverInterface object
     *  @param name constraint name
     *  @param nz number of variables with non-zero coefficients in this row
     *  @param cols index of variables that appear in this row
     *  @param coefs cofficients that that variables appear
     *  @param sense constraint sense: L if <=, G if >=, E if =, R if ranged and N if free
     *  @param rhs right hand size
     * */
public static native void Osi_addRow(Pointer osi, @Cast("const char*") BytePointer name, int nz,
  @Const IntPointer cols, @Const DoublePointer coefs, @Cast("char") byte sense, double rhs);
public static native void Osi_addRow(Pointer osi, String name, int nz,
  @Const IntBuffer cols, @Const DoubleBuffer coefs, @Cast("char") byte sense, double rhs);
public static native void Osi_addRow(Pointer osi, @Cast("const char*") BytePointer name, int nz,
  @Const int[] cols, @Const double[] coefs, @Cast("char") byte sense, double rhs);
public static native void Osi_addRow(Pointer osi, String name, int nz,
  @Const IntPointer cols, @Const DoublePointer coefs, @Cast("char") byte sense, double rhs);
public static native void Osi_addRow(Pointer osi, @Cast("const char*") BytePointer name, int nz,
  @Const IntBuffer cols, @Const DoubleBuffer coefs, @Cast("char") byte sense, double rhs);
public static native void Osi_addRow(Pointer osi, String name, int nz,
  @Const int[] cols, @Const double[] coefs, @Cast("char") byte sense, double rhs);

/** \brief Deletes an OsiSolverInterface object */
public static native void Osi_deleteSolver( Pointer osi );

/*@}*/

/** \name OsiCuts related routines (used in callbacks) */

/** adds a row cut (used in callback) */
public static native void OsiCuts_addRowCut( Pointer osiCuts, int nz, @Const IntPointer idx, @Const DoublePointer coef, @Cast("char") byte sense, double rhs );
public static native void OsiCuts_addRowCut( Pointer osiCuts, int nz, @Const IntBuffer idx, @Const DoubleBuffer coef, @Cast("char") byte sense, double rhs );
public static native void OsiCuts_addRowCut( Pointer osiCuts, int nz, @Const int[] idx, @Const double[] coef, @Cast("char") byte sense, double rhs );

/*@}*/

// #ifdef __cplusplus
// #endif
// #endif

/* vi: softtabstop=2 shiftwidth=2 expandtab tabstop=2
*/


}
